from __future__ import annotations

import httpx
import pytest
from contextlib import contextmanager

from fastapi.testclient import TestClient

import app.deps as deps
from app.config import settings
from app.domain import models as m
from app.agentic.tools import jira_epic_tool
from app.adapters import jira_adapter


def _po_headers(client: TestClient) -> dict[str, str]:
    response = client.post("/auth/token?username=po_admin&password=x")
    assert response.status_code == 200, response.text
    return {"Authorization": f"Bearer {response.json()['access_token']}"}


def _seed_ids() -> tuple[int, int]:
    with deps.SessionLocal() as session:
        project = session.query(m.Project).filter(m.Project.key == "PX").one()
        developer = (
            session.query(m.Developer)
            .join(m.User, m.User.id == m.Developer.user_id)
            .filter(m.User.username == "dev_alex")
            .one()
        )
        return project.id, developer.id


@pytest.fixture(autouse=True)
def _atl_settings(monkeypatch: pytest.MonkeyPatch) -> None:
    monkeypatch.setattr(settings, "atlassian_base_url", "https://example.atlassian.net")
    monkeypatch.setattr(settings, "atlassian_email", "po@example.com")
    monkeypatch.setattr(settings, "atlassian_api_token", "token-123")
    monkeypatch.setattr(settings, "atlassian_epic_name_field_id", None)


@pytest.fixture
def _planner_stub(monkeypatch: pytest.MonkeyPatch) -> None:
    def _plan(*_: object, **__: object) -> dict[str, object]:
        return {
            "steps": [
                {
                    "tool": "jira_epic",
                    "args": {
                        "project_id": None,  # filled per-test via execute stub
                        "summary": "PX Onboarding Epic",
                        "description": "Generated by test",
                        "labels": ["onboarding"],
                    },
                }
            ],
            "output": {"summary": "Plan summary", "gaps": [], "two_week_plan": []},
            "_meta": {},
        }

    monkeypatch.setattr("app.ports.planner.create_plan", _plan)


def test_onboarding_epic_create_with_epic_name_allowed(
    monkeypatch: pytest.MonkeyPatch,
    client: TestClient,
    _planner_stub: None,
) -> None:
    project_id, developer_id = _seed_ids()
    captured_posts: list[dict[str, object]] = []

    def _execute_plan(
        plan: dict[str, object],
        user_claims: dict[str, object],
        **__: object,
    ) -> dict[str, object]:
        plan_steps = plan.get("steps", [])
        artifacts: dict[str, object] = {}
        for index, step in enumerate(plan_steps, start=1):
            args = dict(step.get("args", {}))
            args["project_id"] = str(project_id)
            result = jira_epic_tool(user_claims=user_claims, **args)
            artifacts[f"step_{index}:{step.get('tool')}"] = result
        return {
            "output": {"summary": "Plan summary", "gaps": [], "two_week_plan": []},
            "artifacts": artifacts,
        }

    @contextmanager
    def _fake_sync_client(timeout: float | None = None):
        class _Client:
            def post(self, url: str, headers: dict[str, str] | None = None, json: dict[str, object] | None = None) -> httpx.Response:
                captured_posts.append({"url": url, "json": json or {}, "headers": headers or {}})
                request = httpx.Request("POST", url)
                return httpx.Response(201, request=request, json={"key": "PX-99"})

            def close(self) -> None:  # pragma: no cover - interface requirement
                pass

        yield _Client()

    monkeypatch.setattr("app.ports.planner.execute_plan", _execute_plan)
    monkeypatch.setattr(jira_adapter, "resolve_project", lambda project_key=None, project_id=None: {"id": "1001", "key": "PX"})
    monkeypatch.setattr(jira_adapter, "get_epic_name_field_id", lambda: "customfield_10011")
    monkeypatch.setattr(jira_adapter, "_epic_name_allowed_on_create", lambda *_, **__: True)
    monkeypatch.setattr(jira_adapter, "sync_client", _fake_sync_client)

    response = client.post(
        "/onboarding/generate",
        headers=_po_headers(client),
        json={"project_id": project_id, "developer_id": developer_id},
    )

    assert response.status_code == 200, response.text
    assert captured_posts, "Expected Jira POST to be captured"
    fields = captured_posts[0]["json"].get("fields", {})
    assert fields.get("customfield_10011") == "PX Onboarding Epic"


def test_onboarding_epic_create_without_epic_name_allowed(
    monkeypatch: pytest.MonkeyPatch,
    client: TestClient,
    _planner_stub: None,
) -> None:
    project_id, developer_id = _seed_ids()
    captured_posts: list[dict[str, object]] = []

    def _execute_plan(
        plan: dict[str, object],
        user_claims: dict[str, object],
        **__: object,
    ) -> dict[str, object]:
        artifacts: dict[str, object] = {}
        for index, step in enumerate(plan.get("steps", []), start=1):
            args = dict(step.get("args", {}))
            args["project_id"] = str(project_id)
            result = jira_epic_tool(user_claims=user_claims, **args)
            artifacts[f"step_{index}:{step.get('tool')}"] = result
        return {
            "output": {"summary": "Plan summary", "gaps": [], "two_week_plan": []},
            "artifacts": artifacts,
        }

    @contextmanager
    def _fake_sync_client(timeout: float | None = None):
        class _Client:
            def post(self, url: str, headers: dict[str, str] | None = None, json: dict[str, object] | None = None) -> httpx.Response:
                captured_posts.append({"url": url, "json": json or {}, "headers": headers or {}})
                request = httpx.Request("POST", url)
                return httpx.Response(201, request=request, json={"key": "PX-100"})

            def close(self) -> None:  # pragma: no cover - interface requirement
                pass

        yield _Client()

    monkeypatch.setattr("app.ports.planner.execute_plan", _execute_plan)
    monkeypatch.setattr(jira_adapter, "resolve_project", lambda project_key=None, project_id=None: {"id": "1001", "key": "PX"})
    monkeypatch.setattr(jira_adapter, "get_epic_name_field_id", lambda: "customfield_10011")
    monkeypatch.setattr(jira_adapter, "_epic_name_allowed_on_create", lambda *_, **__: False)
    monkeypatch.setattr(jira_adapter, "sync_client", _fake_sync_client)

    response = client.post(
        "/onboarding/generate",
        headers=_po_headers(client),
        json={"project_id": project_id, "developer_id": developer_id},
    )

    assert response.status_code == 200, response.text
    assert captured_posts, "Expected Jira POST to be captured"
    fields = captured_posts[0]["json"].get("fields", {})
    assert "customfield_10011" not in fields


def test_onboarding_epic_create_400_then_retry_without_field(
    monkeypatch: pytest.MonkeyPatch,
    client: TestClient,
    _planner_stub: None,
) -> None:
    project_id, developer_id = _seed_ids()
    captured_posts: list[dict[str, object]] = []

    def _execute_plan(
        plan: dict[str, object],
        user_claims: dict[str, object],
        **__: object,
    ) -> dict[str, object]:
        artifacts: dict[str, object] = {}
        for index, step in enumerate(plan.get("steps", []), start=1):
            args = dict(step.get("args", {}))
            args["project_id"] = str(project_id)
            result = jira_epic_tool(user_claims=user_claims, **args)
            artifacts[f"step_{index}:{step.get('tool')}"] = result
        return {
            "output": {"summary": "Plan summary", "gaps": [], "two_week_plan": []},
            "artifacts": artifacts,
        }

    class _Client:
        def __init__(self) -> None:
            self.calls = 0

        def post(self, url: str, headers: dict[str, str] | None = None, json: dict[str, object] | None = None) -> httpx.Response:
            self.calls += 1
            captured_posts.append({"url": url, "json": json or {}, "headers": headers or {}, "call": self.calls})
            request = httpx.Request("POST", url)
            if self.calls == 1:
                body = {
                    "errorMessages": [],
                    "errors": {"customfield_10011": "customfield_10011 cannot be set. It is not on the appropriate screen, or unknown."},
                }
                return httpx.Response(400, request=request, json=body)
            return httpx.Response(201, request=request, json={"key": "PX-101"})

        def close(self) -> None:  # pragma: no cover - interface requirement
            pass

    @contextmanager
    def _fake_sync_client(timeout: float | None = None):
        yield _Client()

    monkeypatch.setattr("app.ports.planner.execute_plan", _execute_plan)
    monkeypatch.setattr(jira_adapter, "resolve_project", lambda project_key=None, project_id=None: {"id": "1001", "key": "PX"})
    monkeypatch.setattr(jira_adapter, "get_epic_name_field_id", lambda: "customfield_10011")
    monkeypatch.setattr(jira_adapter, "_epic_name_allowed_on_create", lambda *_, **__: True)
    monkeypatch.setattr(jira_adapter, "sync_client", _fake_sync_client)

    response = client.post(
        "/onboarding/generate",
        headers=_po_headers(client),
        json={"project_id": project_id, "developer_id": developer_id},
    )

    assert response.status_code == 200, response.text
    assert len(captured_posts) == 2
    first_fields = captured_posts[0]["json"].get("fields", {})
    second_fields = captured_posts[1]["json"].get("fields", {})
    assert "customfield_10011" in first_fields
    assert "customfield_10011" not in second_fields


def test_onboarding_schema_requires_project_and_developer(client: TestClient) -> None:
    response = client.post(
        "/onboarding/generate",
        headers=_po_headers(client),
        json={"project_id": 1},
    )
    assert response.status_code == 422
    assert response.json()["detail"][0]["loc"][-1] == "developer_id"
